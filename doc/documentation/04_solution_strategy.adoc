[[section-solution-strategy]]
== Lösungsstrategie

****
Kurzer Überblick über die grundlegenden Entscheidungen und Lösungsansätze, die Entwurf und Implementierung des Systems prägen.
Hierzu gehören:

* Technologieentscheidungen
* Entscheidungen über die Top-Level-Zerlegung des Systems, beispielsweise die Verwendung gesamthaft prägender Entwurfs- oder Architekturmuster,
* Entscheidungen zur Erreichung der wichtigsten Qualitätsanforderungen sowie

Eine *kurze* und *präzise* Darlegung aller relevanten Entscheidungen.
****

=== Controller Tests

****
Eine Schwierigkeit der Controller-Tests liegt in der Berücksichtigung der sicherheitsrelevanten Aspekte von
`spring-security` und `keycloak`.
Wir hatten uns zunächst dafür entschieden diesen Teil zu mocken.
Anfangs hatten wir Probleme, `@WithMockUser` zu verwenden, daher entschieden wir uns für das Mocken des gesamten SecurityContext.
Durch  `SecurityContextUtil` wird dieser jedem ControllerTest zur Verfügung gestellt.
Später wurden wir dann auf die Bibliothek `spring-security-test-keycloack-addons` aufmerksam, die das Testen massiv vereinfacht.
Nun kann man die Annotation `@WithMockKeycloakAuth` benutzen, um Tests mit einer gültigen Keycloak Authentifizierung auszustatten.
****

=== Datenbank

****
Zur Auswahl standen hier MySQL, MariaDB und PostgreSQL, da wir mit diesen Datenbanken bereits Erfahrungen gesammelt haben.

Der Großteil unserer Erfahrungen beruhte bisher auf MySQL, also haben wir uns zunächst für die neuere Variante MariaDB entschieden.

Leider dauerte das Starten der MariaDB-Datenbank in einem Docker-Container recht lange (ähnlich wie MySQL) und es ist umständlich immer diesen Docker-Container laufen zu lassen.
Also haben wir uns entschieden in der Entwicklung und zum Testen H2 zu benutzen.
Das ist eine Embedded In-Memory Datenbank, die sehr schnell startet und die wir ebenfalls schon kennen gelernt haben.

Nach einiger Zeit sind wir dann doch auf PostgreSQL umgestiegen, weil es von den Server-Admins der HHU bevorzugt wird und für ein Testdeployment auf Heroku notwendig ist.
Das war ein schmerzloser Prozess, da wir bis dahin noch nichts mit der echten Datenbank gemacht haben.
****

=== Logging

****
Für das Logging haben wir uns zunächst auf zwei Fälle beschränkt.
Zum einen `info` und `error`.
Die `info` werden ausschließlich in den Controller geschrieben, da es sonst zu redundanten Lognachrichten kommen würde.
Dies ist ausreichend, da jede Aktion unserer Applikation von einem Controller gestartet wird.

Die `error`-Nachrichten werden an jeder Stelle geschrieben, wo auch eine `Exception` geschmissen wird.
Dies soll es einfach im Log machen den `Stacktrace` nach zu verfolgen.

Als Technologie benutzen wir `SLF4J` (Simple Logging Face for Java).
Dies ist nativ in `Spring-Boot 2.x` und lässt sich mit einer einfachen Annotation (`SLF4J`) jeder Klasse hinzufügen.

Wir haben `SLF4J` nicht konfiguriert, also wird standardmäßig `Logback` benutzt.

Wir haben uns dafür entschieden, weil unsere Internetrecherche die meisten Treffer dazu ergeben hat und unser Tutor uns unabhängig davon zu geraten hat.
Die Einfachheit des Tools ist ebenfalls ein Entscheidungsgrund gewesen.

****
