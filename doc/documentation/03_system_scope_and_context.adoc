[[section-system-scope-and-context]]
== Kontextabgrenzung

****
_Die (technische) Abgrenzung gegenüber allen Kommunikationsbeziehungen (Nachbarsysteme und Benutzerrollen).
Somit werden die externen Schnittstellen festgelegt._

_Festlegung *aller* Kommunikationsbeziehungen mit Erklärung der *fachlichen* Ein- und Ausgabedaten._

_Kontextdiagramme, Listen von Kommunikationsbeziehungen aber auch plain text wären denkbar._
****

[cols="1,1,1" options="header"]
|===
|Kommunikationsbeziehung |Eingabe | Ausgabe
| Requests vom Gruppensystem | _Wir erhalten Requests für die Ordner-/Dateierstellung oder Löschung und den Erhalt von
Dateien aus unserer Datenbank._ | _Wir liefern eine Bestätigung des betreffenden Requests (eventuell inklusive der
gewollten Datei) zurück, wenn die entsprechenden Berechtigungen vorhanden waren. Ansonsten bearbeiten wir den Request
nicht._
| Erfragen von Berechtigungen | _Wir erfragen mit einer Gruppen ID und dem Benutzernamen die Berechtigungen eines
Nutzers in einer bestimmten Gruppe._  | _Wir erhalten ein Datenobjekt (.json) zurück, dass alle Berechtigungen (Rollen) des betreffenden Nutzers beinhaltet._
|===

include::../api/external-api.adoc[]

****
PermissionService::

Wir haben einen `PermissionService` implementiert, der unsere Anfragen an die Gruppe `GruppenFindung` stellt.
Dieser stellt zwei Anfragen:
Eine für die Rolle eines Nutzers innerhalb einer Gruppe und einmal alle Rollen in einer Gruppe.

Da während der Entwicklungszeit der externe Service uns nicht zur Verfügung steht, haben wir einen Stub entwickelt, welcher fixe Rollen zurückgibt.
Wir haben uns dazu an der RESTApi Wiki von GruppenFindung orientiert.

****

****
GroupService

Der Service, der unsere Gruppenverwaltung abwickelt, muss mit der GruppenFindung interagieren.
Dazu haben wir folgende REST API Anfragen implementiert:

. `getAllGroups`
. `getAllGroups`

Diese unterscheiden sich, dass die erste alle Gruppen eines Nutzers anfragt und die zweite alle Gruppen, die existieren erfragt.
Die erste brauchen wir für unsere Startseite des Nutzers und die zweite für unsere Garbage Collection.
Damit können wir alle nicht mehr vorhanden Gruppen löschen.
****
